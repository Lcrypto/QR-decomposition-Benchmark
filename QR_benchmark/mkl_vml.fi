! file: mkl_vml.fi
!
!                             INTEL CONFIDENTIAL
!  Copyright(C) 2006-2010 Intel Corporation. All Rights Reserved.
!  The source code contained  or  described herein and all documents related to
!  the source code ("Material") are owned by Intel Corporation or its suppliers
!  or licensors.  Title to the  Material remains with  Intel Corporation or its
!  suppliers and licensors. The Material contains trade secrets and proprietary
!  and  confidential  information of  Intel or its suppliers and licensors. The
!  Material  is  protected  by  worldwide  copyright  and trade secret laws and
!  treaty  provisions. No part of the Material may be used, copied, reproduced,
!  modified, published, uploaded, posted, transmitted, distributed or disclosed
!  in any way without Intel's prior express written permission.
!  No license  under any  patent, copyright, trade secret or other intellectual
!  property right is granted to or conferred upon you by disclosure or delivery
!  of the Materials,  either expressly, by implication, inducement, estoppel or
!  otherwise.  Any  license  under  such  intellectual property  rights must be
!  express and approved by Intel in writing.
!++
!  Fortran 90 VML interface.
!--

!++
!  PARAMETER DEFINITIONS
!  Parameter definitions for VML mode and VML error status.
!
!  VML mode controls VML function accuracy, floating-point settings (rounding
!  mode and precision) and VML error handling options. Default VML mode is
!  VML_HA | VML_ERRMODE_DEFAULT, i.e. VML high accuracy functions are
!  called, and current floating-point precision and the rounding mode is used.
!
!  Error status macros are used for error classification.
!
!  NOTE: A | B means bitwise OR operation with A and B
!--

!  VML FUNCTION ACCURACY CONTROL
!  VML_HA - when VML_HA is set, high accuracy VML functions are called
!  VML_LA - when VML_LA is set, low accuracy VML functions are called
!  VML_EP - when VML_EP is set, enhanced performance VML functions are called
!
!  NOTE: VML_HA, VML_LA and VML_EP must not be used in combination
      INTEGER(KIND=4) VML_LA
      INTEGER(KIND=4) VML_HA
      INTEGER(KIND=4) VML_EP
      PARAMETER (VML_LA = Z"00000001")
      PARAMETER (VML_HA = Z"00000002")
      PARAMETER (VML_EP = Z"00000003")

!  SETTING OPTIMAL FLOATING-POINT PRECISION AND ROUNDING MODE
!  Definitions below are to set optimal floating-point control word
!  (precision and rounding mode).
!
!  For their correct work, VML functions change floating-point precision and
!  rounding mode (if necessary). Since control word changing is typically
!  expensive operation, it is recommended to set precision and rounding mode
!  to optimal values before VML function calls.
!
!  VML_FLOAT_CONSISTENT  - use this value if the calls are typically to single
!                          precision VML functions
!  VML_DOUBLE_CONSISTENT - use this value if the calls are typically to double
!                          precision VML functions
!  VML_RESTORE           - restore original floating-point precision and
!                          rounding mode
!  VML_DEFAULT_PRECISION - use default (current) floating-point precision and
!                          rounding mode
!  NOTE: VML_FLOAT_CONSISTENT, VML_DOUBLE_CONSISTENT, VML_RESTORE and
!        VML_DEFAULT_PRECISION must not be used in combination
      INTEGER(KIND=4) VML_DEFAULT_PRECISION
      INTEGER(KIND=4) VML_FLOAT_CONSISTENT
      INTEGER(KIND=4) VML_DOUBLE_CONSISTENT
      INTEGER(KIND=4) VML_RESTORE
      PARAMETER (VML_DEFAULT_PRECISION = Z"00000000")
      PARAMETER (VML_FLOAT_CONSISTENT  = Z"00000010")
      PARAMETER (VML_DOUBLE_CONSISTENT = Z"00000020")
      PARAMETER (VML_RESTORE           = Z"00000030")

!  VML ERROR HANDLING CONTROL
!  Macros below are used to control VML error handler.
!
!  VML_ERRMODE_IGNORE   - ignore errors
!  VML_ERRMODE_ERRNO    - errno variable is set on error
!  VML_ERRMODE_STDERR   - error description text is written to stderr on error
!  VML_ERRMODE_EXCEPT   - exception is raised on error
!  VML_ERRMODE_CALLBACK - user's error handler function is called on error
!  VML_ERRMODE_DEFAULT  - errno variable is set, exceptions are raised and
!                         user's error handler is called on error
!  NOTE: VML_ERRMODE_IGNORE must not be used in combination with
!        VML_ERRMODE_ERRNO, VML_ERRMODE_STDERR, VML_ERRMODE_EXCEPT,
!        VML_ERRMODE_CALLBACK and VML_ERRMODE_DEFAULT.
      INTEGER(KIND=4) VML_ERRMODE_IGNORE
      INTEGER(KIND=4) VML_ERRMODE_ERRNO
      INTEGER(KIND=4) VML_ERRMODE_STDERR
      INTEGER(KIND=4) VML_ERRMODE_EXCEPT
      INTEGER(KIND=4) VML_ERRMODE_CALLBACK
      INTEGER(KIND=4) VML_ERRMODE_DEFAULT
      PARAMETER (VML_ERRMODE_IGNORE   = Z"00000100")
      PARAMETER (VML_ERRMODE_ERRNO    = Z"00000200")
      PARAMETER (VML_ERRMODE_STDERR   = Z"00000400")
      PARAMETER (VML_ERRMODE_EXCEPT   = Z"00000800")
      PARAMETER (VML_ERRMODE_CALLBACK = Z"00001000")
      PARAMETER (VML_ERRMODE_DEFAULT  = IOR(VML_ERRMODE_ERRNO,          &
     &           IOR(VML_ERRMODE_CALLBACK,VML_ERRMODE_EXCEPT)))

!  ACCURACY, FLOATING-POINT CONTROL AND ERROR HANDLING MASKS
!  Accuracy, floating-point and error handling control are packed in
!  the VML mode variable. Macros below are useful to extract accuracy and/or
!  floating-point control and/or error handling control settings.
!
!  VML_ACCURACY_MASK           - extract accuracy bits
!  VML_FPUMODE_MASK            - extract floating-point control bits
!  VML_ERRMODE_MASK            - extract error handling control bits
!                                (including error callback bits)
!  VML_ERRMODE_STDHANDLER_MASK - extract error handling control bits
!                                (not including error callback bits)
!  VML_ERRMODE_CALLBACK_MASK   - extract error callback bits
      INTEGER(KIND=4) VML_ACCURACY_MASK
      INTEGER(KIND=4) VML_FPUMODE_MASK
      INTEGER(KIND=4) VML_ERRMODE_MASK
      INTEGER(KIND=4) VML_ERRMODE_STDHANDLER_MASK
      INTEGER(KIND=4) VML_ERRMODE_CALLBACK_MASK
      PARAMETER (VML_ACCURACY_MASK = Z"0000000f")
      PARAMETER (VML_FPUMODE_MASK  = Z"000000f0")
      PARAMETER (VML_ERRMODE_MASK  = Z"0000ff00")
      PARAMETER (VML_ERRMODE_STDHANDLER_MASK = Z"00000f00")
      PARAMETER (VML_ERRMODE_CALLBACK_MASK = Z"0000f000")

!  ERROR STATUS PARAMETER DEFINITIONS
!  VML_STATUS_OK        - no errors
!  VML_STATUS_BADSIZE   - array dimension is not positive
!  VML_STATUS_BADMEM    - invalid pointer passed
!  VML_STATUS_ERRDOM    - at least one of arguments is out of function domain
!  VML_STATUS_SING      - at least one of arguments caused singularity
!  VML_STATUS_OVERFLOW  - at least one of arguments caused overflow
!  VML_STATUS_UNDERFLOW - at least one of arguments caused underflow
      INTEGER(KIND=4) VML_STATUS_OK
      INTEGER(KIND=4) VML_STATUS_BADSIZE
      INTEGER(KIND=4) VML_STATUS_BADMEM
      INTEGER(KIND=4) VML_STATUS_ERRDOM
      INTEGER(KIND=4) VML_STATUS_SING
      INTEGER(KIND=4) VML_STATUS_OVERFLOW
      INTEGER(KIND=4) VML_STATUS_UNDERFLOW
      PARAMETER (VML_STATUS_OK        = 0)
      PARAMETER (VML_STATUS_BADSIZE   = -1)
      PARAMETER (VML_STATUS_BADMEM    = -2)
      PARAMETER (VML_STATUS_ERRDOM    = 1)
      PARAMETER (VML_STATUS_SING      = 2)
      PARAMETER (VML_STATUS_OVERFLOW  = 3)
      PARAMETER (VML_STATUS_UNDERFLOW = 4)

!++
!  TYPE DEFINITIONS
!--

!  ERROR CALLBACK CONTEXT.
!  Error callback context structure is used in a user's error callback
!  function with the following interface:
!
!  Error callback context fields:
!  ICODE        - error status
!  IINDEX       - index of bad argument
!  DBA1         - 1-st argument value, at which error occured
!  DBA2         - 2-nd argument value, at which error occured
!                 (2-argument functions only)
!  DBR1         - 1-st resulting value
!  DBR2         - 2-nd resulting value (2-result functions only)
!  CFUNCNAME    - function name, for which error occured
!  IFUNCNAMELEN - length of function name
      !dec$ options /warn=noalignment
      TYPE ERROR_STRUCTURE
            SEQUENCE
            INTEGER(KIND=4) ICODE
            INTEGER(KIND=4) IINDEX
            REAL(KIND=8)    DBA1
            REAL(KIND=8)    DBA2
            REAL(KIND=8)    DBR1
            REAL(KIND=8)    DBR2
            CHARACTER(64)   CFUNCNAME
            INTEGER(KIND=4) IFUNCNAMELEN
      END TYPE ERROR_STRUCTURE
      !dec$ end options

!++
!  VML ELEMENTARY FUNCTION INTERFACES.
!--

!  Absolute value: r[i] = |a[i]|

      INTERFACE
        SUBROUTINE vsabs(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdabs(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Complex absolute value: r[i] = |a[i]|

      INTERFACE
        SUBROUTINE vcabs(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=4),INTENT(IN)  :: a(n)
          REAL(KIND=4),INTENT(OUT)    :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vzabs(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=8),INTENT(IN)  :: a(n)
          REAL(KIND=8),INTENT(OUT)    :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Argument of complex value: r[i] = carg(a[i])

      INTERFACE
        SUBROUTINE vcarg(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=4),INTENT(IN)  :: a(n)
          REAL(KIND=4),INTENT(OUT)    :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vzarg(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=8),INTENT(IN)  :: a(n)
          REAL(KIND=8),INTENT(OUT)    :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Addition: r[i] = a[i] + b[i]

      INTERFACE
        SUBROUTINE vsadd(n,a,b,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n),b(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdadd(n,a,b,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n),b(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Complex addition: r[i] = a[i] + b[i]

      INTERFACE
        SUBROUTINE vcadd(n,a,b,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=4),INTENT(IN)  :: a(n),b(n)
          COMPLEX(KIND=4),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vzadd(n,a,b,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=8),INTENT(IN)  :: a(n),b(n)
          COMPLEX(KIND=8),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Subtraction: r[i] = a[i] - b[i]

      INTERFACE
        SUBROUTINE vssub(n,a,b,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n),b(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdsub(n,a,b,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n),b(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Complex subtraction: r[i] = a[i] - b[i]

      INTERFACE
        SUBROUTINE vcsub(n,a,b,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=4),INTENT(IN)  :: a(n),b(n)
          COMPLEX(KIND=4),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vzsub(n,a,b,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=8),INTENT(IN)  :: a(n),b(n)
          COMPLEX(KIND=8),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Reciprocal: r[i] = 1.0 / a[i]

      INTERFACE
        SUBROUTINE vsinv(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdinv(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Square Root: r[i] = a[i]^0.5

      INTERFACE
        SUBROUTINE vssqrt(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdsqrt(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Complex Square Root: r[i] = a[i]^0.5

      INTERFACE
        SUBROUTINE vcsqrt(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=4),INTENT(IN)  :: a(n)
          COMPLEX(KIND=4),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vzsqrt(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=8),INTENT(IN)  :: a(n)
          COMPLEX(KIND=8),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Reciprocal Square Root: r[i] = 1/a[i]^0.5

      INTERFACE
        SUBROUTINE vsinvsqrt(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdinvsqrt(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Cube Root: r[i] = a[i]^(1/3)

      INTERFACE
        SUBROUTINE vscbrt(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdcbrt(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Reciprocal Cube Root: r[i] = 1/a[i]^(1/3)

      INTERFACE
        SUBROUTINE vsinvcbrt(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdinvcbrt(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Squaring: r[i] = a[i]^2

      INTERFACE
        SUBROUTINE vssqr(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdsqr(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Exponential Function: r[i] = e^a[i]

      INTERFACE
        SUBROUTINE vsexp(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdexp(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Complex Exponential Function: r[i] = e^a[i]

      INTERFACE
        SUBROUTINE vcexp(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=4),INTENT(IN)  :: a(n)
          COMPLEX(KIND=4),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vzexp(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=8),INTENT(IN)  :: a(n)
          COMPLEX(KIND=8),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

!  : r[i] = e^(a[i]-1)

      INTERFACE
        SUBROUTINE vsexpm1(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdexpm1(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Logarithm (base e): r[i] = ln(a[i])

      INTERFACE
        SUBROUTINE vsln(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdln(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Complex Logarithm (base e): r[i] = ln(a[i])

      INTERFACE
        SUBROUTINE vcln(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=4),INTENT(IN)  :: a(n)
          COMPLEX(KIND=4),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vzln(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=8),INTENT(IN)  :: a(n)
          COMPLEX(KIND=8),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Logarithm (base 10): r[i] = lg(a[i])

      INTERFACE
        SUBROUTINE vslog10(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdlog10(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  : r[i] = log(1+a[i])

      INTERFACE
        SUBROUTINE vslog1p(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdlog1p(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Complex Logarithm (base 10): r[i] = lg(a[i])

      INTERFACE
        SUBROUTINE vclog10(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=4),INTENT(IN)  :: a(n)
          COMPLEX(KIND=4),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vzlog10(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=8),INTENT(IN)  :: a(n)
          COMPLEX(KIND=8),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Sine: r[i] = sin(a[i])

      INTERFACE
        SUBROUTINE vssin(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdsin(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Complex Sine: r[i] = sin(a[i])

      INTERFACE
        SUBROUTINE vcsin(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=4),INTENT(IN)  :: a(n)
          COMPLEX(KIND=4),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vzsin(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=8),INTENT(IN)  :: a(n)
          COMPLEX(KIND=8),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Cosine: r[i] = cos(a[i])

      INTERFACE
        SUBROUTINE vscos(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdcos(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Complex Cosine: r[i] = cos(a[i])

      INTERFACE
        SUBROUTINE vccos(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=4),INTENT(IN)  :: a(n)
          COMPLEX(KIND=4),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vzcos(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=8),INTENT(IN)  :: a(n)
          COMPLEX(KIND=8),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Tangent: r[i] = tan(a[i])

      INTERFACE
        SUBROUTINE vstan(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdtan(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Complex Tangent: r[i] = tan(a[i])

      INTERFACE
        SUBROUTINE vctan(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=4),INTENT(IN)  :: a(n)
          COMPLEX(KIND=4),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vztan(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=8),INTENT(IN)  :: a(n)
          COMPLEX(KIND=8),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Hyperbolic Sine: r[i] = sh(a[i])

      INTERFACE
        SUBROUTINE vssinh(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdsinh(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Complex Hyperbolic Sine: r[i] = sh(a[i])

      INTERFACE
        SUBROUTINE vcsinh(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=4),INTENT(IN)  :: a(n)
          COMPLEX(KIND=4),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vzsinh(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=8),INTENT(IN)  :: a(n)
          COMPLEX(KIND=8),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Hyperbolic Cosine: r[i] = ch(a[i])

      INTERFACE
        SUBROUTINE vscosh(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdcosh(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Complex Hyperbolic Cosine: r[i] = ch(a[i])

      INTERFACE
        SUBROUTINE vccosh(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=4),INTENT(IN)  :: a(n)
          COMPLEX(KIND=4),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vzcosh(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=8),INTENT(IN)  :: a(n)
          COMPLEX(KIND=8),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Hyperbolic Tangent: r[i] = th(a[i])

      INTERFACE
        SUBROUTINE vstanh(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdtanh(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Complex Hyperbolic Tangent: r[i] = th(a[i])

      INTERFACE
        SUBROUTINE vctanh(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=4),INTENT(IN)  :: a(n)
          COMPLEX(KIND=4),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vztanh(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=8),INTENT(IN)  :: a(n)
          COMPLEX(KIND=8),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Arc Cosine: r[i] = arccos(a[i])

      INTERFACE
        SUBROUTINE vsacos(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdacos(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Complex Arc Cosine: r[i] = arccos(a[i])

      INTERFACE
        SUBROUTINE vcacos(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=4),INTENT(IN)  :: a(n)
          COMPLEX(KIND=4),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vzacos(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=8),INTENT(IN)  :: a(n)
          COMPLEX(KIND=8),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Arc Sine: r[i] = arcsin(a[i])

      INTERFACE
        SUBROUTINE vsasin(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdasin(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Complex Arc Sine: r[i] = arcsin(a[i])

      INTERFACE
        SUBROUTINE vcasin(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=4),INTENT(IN)  :: a(n)
          COMPLEX(KIND=4),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vzasin(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=8),INTENT(IN)  :: a(n)
          COMPLEX(KIND=8),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Arc Tangent: r[i] = arctan(a[i])

      INTERFACE
        SUBROUTINE vsatan(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdatan(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Complex Arc Tangent: r[i] = arctan(a[i])

      INTERFACE
        SUBROUTINE vcatan(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=4),INTENT(IN)  :: a(n)
          COMPLEX(KIND=4),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vzatan(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=8),INTENT(IN)  :: a(n)
          COMPLEX(KIND=8),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Hyperbolic Arc Cosine: r[i] = arcch(a[i])

      INTERFACE
        SUBROUTINE vsacosh(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdacosh(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Complex Hyperbolic Arc Cosine: r[i] = arcch(a[i])

      INTERFACE
        SUBROUTINE vcacosh(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=4),INTENT(IN)  :: a(n)
          COMPLEX(KIND=4),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vzacosh(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=8),INTENT(IN)  :: a(n)
          COMPLEX(KIND=8),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Hyperbolic Arc Sine: r[i] = arcsh(a[i])

      INTERFACE
        SUBROUTINE vsasinh(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdasinh(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Complex Hyperbolic Arc Sine: r[i] = arcsh(a[i])

      INTERFACE
        SUBROUTINE vcasinh(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=4),INTENT(IN)  :: a(n)
          COMPLEX(KIND=4),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vzasinh(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=8),INTENT(IN)  :: a(n)
          COMPLEX(KIND=8),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Hyperbolic Arc Tangent: r[i] = arcth(a[i])

      INTERFACE
        SUBROUTINE vsatanh(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdatanh(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Complex Hyperbolic Arc Tangent: r[i] = arcth(a[i])

      INTERFACE
        SUBROUTINE vcatanh(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=4),INTENT(IN)  :: a(n)
          COMPLEX(KIND=4),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vzatanh(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=8),INTENT(IN)  :: a(n)
          COMPLEX(KIND=8),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Error Function: r[i] = erf(a[i])

      INTERFACE
        SUBROUTINE vserf(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vderf(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!

      INTERFACE
        SUBROUTINE vserfinv(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vderfinv(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!

      INTERFACE
        SUBROUTINE vshypot(n,a,b,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(IN)    :: b(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdhypot(n,a,b,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(IN)    :: b(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Complementary Error Function: r[i] = 1 - erf(a[i])

      INTERFACE
        SUBROUTINE vserfc(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vderfc(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!

      INTERFACE
        SUBROUTINE vserfcinv(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vderfcinv(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!

      INTERFACE
        SUBROUTINE vscdfnorm(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdcdfnorm(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!

      INTERFACE
        SUBROUTINE vscdfnorminv(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdcdfnorminv(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Arc Tangent of a/b: r[i] = arctan(a[i]/b[i])

      INTERFACE
        SUBROUTINE vsatan2(n,a,b,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n),b(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdatan2(n,a,b,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n),b(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Division: r[i] = a[i] * b[i]

      INTERFACE
        SUBROUTINE vsmul(n,a,b,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n),b(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdmul(n,a,b,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n),b(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Complex division: r[i] = a[i] * b[i]

      INTERFACE
        SUBROUTINE vcmul(n,a,b,r)
          INTEGER,INTENT(IN) :: n
          COMPLEX(KIND=4),INTENT(IN)    :: a(n),b(n)
          COMPLEX(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vzmul(n,a,b,r)
          INTEGER,INTENT(IN) :: n
          COMPLEX(KIND=8),INTENT(IN)    :: a(n),b(n)
          COMPLEX(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Division: r[i] = a[i] / b[i]

      INTERFACE
        SUBROUTINE vsdiv(n,a,b,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n),b(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vddiv(n,a,b,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n),b(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Complex division: r[i] = a[i] / b[i]

      INTERFACE
        SUBROUTINE vcdiv(n,a,b,r)
          INTEGER,INTENT(IN) :: n
          COMPLEX(KIND=4),INTENT(IN)    :: a(n),b(n)
          COMPLEX(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vzdiv(n,a,b,r)
          INTEGER,INTENT(IN) :: n
          COMPLEX(KIND=8),INTENT(IN)    :: a(n),b(n)
          COMPLEX(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Power Function: r[i] = a[i]^b[i]

      INTERFACE
        SUBROUTINE vspow(n,a,b,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n),b(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdpow(n,a,b,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n),b(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Complex Power Function: r[i] = a[i]^b[i]

      INTERFACE
        SUBROUTINE vcpow(n,a,b,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=4),INTENT(IN)  :: a(n),b(n)
          COMPLEX(KIND=4),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vzpow(n,a,b,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=8),INTENT(IN)  :: a(n),b(n)
          COMPLEX(KIND=8),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Power Function: r[i] = a[i]^(3/2)

      INTERFACE
        SUBROUTINE vspow3o2(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdpow3o2(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Power Function: r[i] = a[i]^(2/3)

      INTERFACE
        SUBROUTINE vspow2o3(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdpow2o3(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Power Function with Fixed Degree: r[i] = a[i]^b

      INTERFACE
        SUBROUTINE vspowx(n,a,b,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: b
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdpowx(n,a,b,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: b
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Complex Power Function with Fixed Degree: r[i] = a[i]^b

      INTERFACE
        SUBROUTINE vcpowx(n,a,b,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=4),INTENT(IN)  :: b
          COMPLEX(KIND=4),INTENT(IN)  :: a(n)
          COMPLEX(KIND=4),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vzpowx(n,a,b,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=8),INTENT(IN)  :: b
          COMPLEX(KIND=8),INTENT(IN)  :: a(n)
          COMPLEX(KIND=8),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

!  Sine & Cosine: r1[i] = sin(a[i]), r2[i]=cos(a[i])

      INTERFACE
        SUBROUTINE vssincos(n,a,r1,r2)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r1(n),r2(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdsincos(n,a,r1,r2)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r1(n),r2(n)
        END SUBROUTINE
      END INTERFACE

!

      INTERFACE
        SUBROUTINE vsceil(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdceil(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!

      INTERFACE
        SUBROUTINE vsfloor(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdfloor(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!

      INTERFACE
        SUBROUTINE vsmodf(n,a,r1,r2)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r1(n),r2(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdmodf(n,a,r1,r2)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r1(n),r2(n)
        END SUBROUTINE
      END INTERFACE

!

      INTERFACE
        SUBROUTINE vsnearbyint(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdnearbyint(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!

      INTERFACE
        SUBROUTINE vsrint(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdrint(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!

      INTERFACE
        SUBROUTINE vsround(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdround(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!

      INTERFACE
        SUBROUTINE vstrunc(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdtrunc(n,a,r)
          INTEGER,INTENT(IN) :: n
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: r(n)
        END SUBROUTINE
      END INTERFACE

!  : r[i] =

      INTERFACE
        SUBROUTINE vcconj(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=4),INTENT(IN)  :: a(n)
          COMPLEX(KIND=4),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vzconj(n,a,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=8),INTENT(IN)  :: a(n)
          COMPLEX(KIND=8),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

!  : r[i] =

      INTERFACE
        SUBROUTINE vcmulbyconj(n,a,b,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=4),INTENT(IN)  :: a(n),b(n)
          COMPLEX(KIND=4),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vzmulbyconj(n,a,b,r)
          INTEGER,INTENT(IN)  :: n
          COMPLEX(KIND=8),INTENT(IN)  :: a(n),b(n)
          COMPLEX(KIND=8),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

!  : r[i] =

      INTERFACE
        SUBROUTINE vccis(n,a,r)
          INTEGER,INTENT(IN)  :: n
          REAL(KIND=4),INTENT(IN)  :: a(n)
          COMPLEX(KIND=4),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vzcis(n,a,r)
          INTEGER,INTENT(IN)  :: n
          REAL(KIND=8),INTENT(IN)  :: a(n)
          COMPLEX(KIND=8),INTENT(OUT) :: r(n)
        END SUBROUTINE
      END INTERFACE

!++
!  VML PACK FUNCTION INTERFACES.
!--

!  Positive Increment Indexing
      INTERFACE
        SUBROUTINE vspacki(n,a,incra,y)
          INTEGER,INTENT(IN) :: n
          INTEGER,INTENT(IN) :: incra
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: y(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdpacki(n,a,incra,y)
          INTEGER,INTENT(IN) :: n
          INTEGER,INTENT(IN) :: incra
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: y(n)
        END SUBROUTINE
      END INTERFACE

!  Index Vector Indexing
      INTERFACE
        SUBROUTINE vspackv(n,a,ia,y)
          INTEGER,INTENT(IN) :: n
          INTEGER,INTENT(IN) :: ia(n)
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: y(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdpackv(n,a,ia,y)
          INTEGER,INTENT(IN) :: n
          INTEGER,INTENT(IN) :: ia(n)
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: y(n)
        END SUBROUTINE
      END INTERFACE

!  Mask Vector Indexing
      INTERFACE
        SUBROUTINE vspackm(n,a,ma,y)
          INTEGER,INTENT(IN) :: n
          INTEGER,INTENT(IN) :: ma(n)
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: y(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdpackm(n,a,ma,y)
          INTEGER,INTENT(IN) :: n
          INTEGER,INTENT(IN) :: ma(n)
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: y(n)
        END SUBROUTINE
      END INTERFACE

!++
!  VML UNPACK FUNCTION DECLARATIONS.
!--

!  Positive Increment Indexing
      INTERFACE
        SUBROUTINE vsunpacki(n,a,y,incry)
          INTEGER,INTENT(IN) :: n
          INTEGER,INTENT(IN) :: incry
          REAL(KIND=4) :: a(n),y(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdunpacki(n,a,y,incry)
          INTEGER,INTENT(IN) :: n
          INTEGER,INTENT(IN) :: incry
          REAL(KIND=8) :: a(n),y(n)
        END SUBROUTINE
      END INTERFACE

!  Index Vector Indexing
      INTERFACE
        SUBROUTINE vsunpackv(n,a,y,iy)
          INTEGER,INTENT(IN) :: n
          INTEGER,INTENT(IN) :: iy(n)
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: y(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdunpackv(n,a,y,iy)
          INTEGER,INTENT(IN) :: n
          INTEGER,INTENT(IN) :: iy(n)
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: y(n)
        END SUBROUTINE
      END INTERFACE

!  Mask Vector Indexing
      INTERFACE
        SUBROUTINE vsunpackm(n,a,y,my)
          INTEGER,INTENT(IN) :: n
          INTEGER,INTENT(IN) :: my(n)
          REAL(KIND=4),INTENT(IN)    :: a(n)
          REAL(KIND=4),INTENT(OUT)   :: y(n)
        END SUBROUTINE
      END INTERFACE

      INTERFACE
        SUBROUTINE vdunpackm(n,a,y,my)
          INTEGER,INTENT(IN) :: n
          INTEGER,INTENT(IN) :: my(n)
          REAL(KIND=8),INTENT(IN)    :: a(n)
          REAL(KIND=8),INTENT(OUT)   :: y(n)
        END SUBROUTINE
      END INTERFACE

!++
!  VML ERROR HANDLING FUNCTION DECLARATIONS.
!--

!  Set VML Error Status
      INTERFACE
        INTEGER(KIND=4) FUNCTION vmlseterrstatus(err)
          INTEGER,INTENT(IN) :: err
        END FUNCTION
      END INTERFACE

!  Get VML Error Status
      INTERFACE
        INTEGER(KIND=4) FUNCTION vmlgeterrstatus()
        END FUNCTION
      END INTERFACE

!  Clear VML Error Status
      INTERFACE
        INTEGER(KIND=4) FUNCTION vmlclearerrstatus()
        END FUNCTION
      END INTERFACE

!  Set VML Error Callback Function
      INTERFACE
        INTEGER(KIND=4) FUNCTION vmlseterrorcallback(cb)
          INTEGER,EXTERNAL :: cb
        END FUNCTION vmlseterrorcallback
      END INTERFACE

!  Get VML Error Callback Function
      INTERFACE
        INTEGER(KIND=4) FUNCTION vmlgeterrorcallback()
        END FUNCTION vmlgeterrorcallback
      END INTERFACE

!  Reset VML Error Callback Function
      INTERFACE
        INTEGER(KIND=4) FUNCTION vmlclearerrorcallback()
        END FUNCTION vmlclearerrorcallback
      END INTERFACE

!++
!  VML MODE FUNCTION DECLARATIONS.
!--

!  Set VML Mode
      INTERFACE
        INTEGER(KIND=4) FUNCTION vmlsetmode(n)
          INTEGER,INTENT(IN) :: n
        END FUNCTION
      END INTERFACE

!  Get VML Mode
      INTERFACE
        INTEGER(KIND=4) FUNCTION vmlgetmode()
        END FUNCTION
      END INTERFACE
